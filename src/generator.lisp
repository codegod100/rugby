(in-package #:ps-asc-demo)

(defstruct arg-spec
  name
  type
  symbol)

(defstruct function-spec
  name
  symbol
  args
  return-type
  body)

(defun ps-symbol (name)
  (intern (string-upcase name) (find-package '#:ps-asc-demo)))

(defun make-arg (name type)
  (make-arg-spec :name name :type type :symbol (ps-symbol name)))

(defun make-function (name args return-type body)
  (make-function-spec :name name
                      :symbol (ps-symbol name)
                      :args args
                      :return-type return-type
                      :body body))

(defparameter *function-specs*
  (let* ((fib (ps-symbol "fib"))
         (n (ps-symbol "n")))
    (list
     (let ((n-arg (make-arg "n" "i32")))
       (make-function "fib"
                      (list n-arg)
                      "i32"
                      `(if (< ,n 2)
                           ,n
                           (+ (,fib (- ,n 1))
                              (,fib (- ,n 2)))))))))

(defun function-spec->ps-form (spec)
  `(defun ,(function-spec-symbol spec)
       ,(mapcar #'arg-spec-symbol (function-spec-args spec))
     ,(function-spec-body spec)))

(defun export-forms ()
  (mapcar (lambda (spec)
            `(setf (@ module exports ,(function-spec-symbol spec))
                   ,(function-spec-symbol spec)))
          *function-specs*))

(defun generate-js-source ()
  (let* ((program `(progn ,@(mapcar #'function-spec->ps-form *function-specs*)
                          ,@(export-forms)))
         (js (parenscript:ps* program)))
    (with-output-to-string (out)
      (format out "/* Auto-generated by ps-asc-demo. */~%~%")
      (write-string js out))))

(defun indent-string (level)
  (make-string (* 2 level) :initial-element #\Space))

(defun if-expression-p (expr)
  (and (consp expr) (eq (car expr) 'if)))

(defun emit-binary (operator args)
  (unless (= (length args) 2)
    (error "Binary operator ~A expects two operands." operator))
  (format nil "~A ~A ~A"
          (emit-expression (first args))
          operator
          (emit-expression (second args))))

(defun emit-expression (expr)
  (cond
    ((numberp expr) (write-to-string expr))
    ((stringp expr) (format nil "\"~A\"" expr))
    ((symbolp expr) (string-downcase (symbol-name expr)))
    ((consp expr)
     (let ((head (car expr))
           (args (cdr expr)))
       (cond
         ((eq head '+) (emit-binary "+" args))
         ((eq head '-) (emit-binary "-" args))
         ((eq head '*) (emit-binary "*" args))
         ((eq head '<) (emit-binary "<" args))
         ((symbolp head)
          (format nil "~A(~{~A~^, ~})"
                  (string-downcase (symbol-name head))
                  (mapcar #'emit-expression args)))
         (t (error "Unsupported expression: ~S" expr)))))
    (t (error "Unsupported expression: ~S" expr))))

(defun emit-returning-body (expr indent)
  (with-output-to-string (out)
    (if (if-expression-p expr)
        (let ((condition (second expr))
              (consequence (third expr))
              (alternative (fourth expr))
              (indent-str (indent-string indent)))
          (format out "~Aif (~A) {~%"
                  indent-str
                  (emit-expression condition))
          (write-string (emit-returning-body consequence (1+ indent)) out)
          (format out "~A} else {~%" indent-str)
          (write-string (emit-returning-body alternative (1+ indent)) out)
          (format out "~A}~%" indent-str))
        (format out "~Areturn ~A;~%"
                (indent-string indent)
                (emit-expression expr)))))

(defun emit-function-spec (spec)
  (with-output-to-string (out)
    (format out "export function ~A(~{~A~^, ~}) : ~A {~%"
      (string-downcase (function-spec-name spec))
      (mapcar (lambda (arg)
          (format nil "~A: ~A"
            (string-downcase (arg-spec-name arg))
            (arg-spec-type arg)))
        (function-spec-args spec))
      (function-spec-return-type spec))
    (write-string (emit-returning-body (function-spec-body spec) 1) out)
    (format out "}~%")))

(defun generate-assemblyscript-source ()
  (with-output-to-string (out)
    (format out "// AssemblyScript view of the Parenscript program.~%")
    (dolist (spec *function-specs*)
      (terpri out)
      (write-string (emit-function-spec spec) out))))

(defun build-directory ()
  (asdf:system-relative-pathname :ps-asc-demo "build/"))

(defun build-path (filename)
  (merge-pathnames filename (build-directory)))

(defun write-build-file (filename content)
  (let ((path (build-path filename)))
    (ensure-directories-exist path)
    (with-open-file (stream path
                            :direction :output
                            :if-exists :supersede
                            :if-does-not-exist :create)
      (write-string content stream)
      path)))

(defun generate-artifacts ()
  (let ((js (generate-js-source))
        (ts (generate-assemblyscript-source)))
    (list (write-build-file "generated.js" js)
          (write-build-file "generated.ts" ts))))
